// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package storegen

import (
	"context"
	"database/sql"
)

const getUnassignedWallet = `-- name: GetUnassignedWallet :one
SELECT id
FROM wallets
WHERE assigned = FALSE
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetUnassignedWallet(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUnassignedWallet)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertIntoWallets = `-- name: InsertIntoWallets :one
INSERT INTO wallets (user_id, usdc_wallet_address, usdc_wallet_address_pk, usdc_balance)
VALUES ($1 :: INT,
        $2 :: VARCHAR(44),
        $3 :: VARCHAR(88),
        $4 :: FLOAT)
RETURNING id
`

type InsertIntoWalletsParams struct {
	UserID              int32
	UsdcWalletAddress   string
	UsdcWalletAddressPk string
	UsdcBalance         float64
}

func (q *Queries) InsertIntoWallets(ctx context.Context, arg InsertIntoWalletsParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertIntoWallets,
		arg.UserID,
		arg.UsdcWalletAddress,
		arg.UsdcWalletAddressPk,
		arg.UsdcBalance,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const lookupWallet = `-- name: LookupWallet :one
SELECT id, user_id, usdc_wallet_address, usdc_wallet_address_pk, usdc_balance, created_at, updated_at, assigned
FROM wallets
WHERE user_id = $1
`

type LookupWalletRow struct {
	ID                  int32
	UserID              int32
	UsdcWalletAddress   string
	UsdcWalletAddressPk string
	UsdcBalance         float64
	CreatedAt           sql.NullTime
	UpdatedAt           sql.NullTime
	Assigned            bool
}

func (q *Queries) LookupWallet(ctx context.Context, userID int32) (LookupWalletRow, error) {
	row := q.db.QueryRowContext(ctx, lookupWallet, userID)
	var i LookupWalletRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UsdcWalletAddress,
		&i.UsdcWalletAddressPk,
		&i.UsdcBalance,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Assigned,
	)
	return i, err
}

const lookupWalletBalance = `-- name: LookupWalletBalance :one
SELECT usdc_balance
FROM wallets
WHERE user_id = $1
`

func (q *Queries) LookupWalletBalance(ctx context.Context, userID int32) (float64, error) {
	row := q.db.QueryRowContext(ctx, lookupWalletBalance, userID)
	var usdc_balance float64
	err := row.Scan(&usdc_balance)
	return usdc_balance, err
}

const updateWalletBalance = `-- name: UpdateWalletBalance :exec
UPDATE wallets
SET usdc_balance = usdc_balance - $1,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $2
`

type UpdateWalletBalanceParams struct {
	UsdcBalance float64
	UserID      int32
}

func (q *Queries) UpdateWalletBalance(ctx context.Context, arg UpdateWalletBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateWalletBalance, arg.UsdcBalance, arg.UserID)
	return err
}

const updateWallets = `-- name: UpdateWallets :one
UPDATE wallets
SET updated_at = CURRENT_TIMESTAMP AT TIME ZONE 'UTC',
    user_id    = COALESCE($1, user_id),
    assigned   = COALESCE($2, assigned)
WHERE id = $3 :: INT
RETURNING id
    , usdc_wallet_address
`

type UpdateWalletsParams struct {
	UserID   int32
	Assigned bool
	ID       int32
}

type UpdateWalletsRow struct {
	ID                int32
	UsdcWalletAddress string
}

func (q *Queries) UpdateWallets(ctx context.Context, arg UpdateWalletsParams) (UpdateWalletsRow, error) {
	row := q.db.QueryRowContext(ctx, updateWallets, arg.UserID, arg.Assigned, arg.ID)
	var i UpdateWalletsRow
	err := row.Scan(&i.ID, &i.UsdcWalletAddress)
	return i, err
}
